ğŸ”„ What is ReentrantLock in Java?
ReentrantLock is a class from the java.util.concurrent.locks package that provides more advanced locking 
capabilities than the traditional synchronized keyword.

ğŸ§  Concept First: What is ReentrantLock?
=========================================
Think of ReentrantLock like a special door lock:
 -Only one person (thread) can go through at a time.
 -The same person (thread) can re-enter the same door multiple times without getting blocked (this is "reentrancy").
 -You can choose to:
	-Try the door: â€œIf itâ€™s open, go in. If not, skip.â€
    -Wait for the door: â€œWait a bit and then leave if itâ€™s still locked.â€
	-Break in if interrupted: â€œHey! You donâ€™t have to wait anymoreâ€”get out!â€


ğŸ“¦ Real-World Scenario:
=======================
ATM Access in a Bank
Imagine a bank with 1 ATM machine.
	-Multiple customers (threads) want to use the ATM.
	-Only one customer can use it at a time.
	-A customer may need to access it multiple times in a session (reentrancy).
	-If itâ€™s busy, some customers may:
		-Wait patiently
		-Leave after some time (timeout)
		-Be told to stop waiting (interruption)
		
		
ğŸ§  Why Use ReentrantLock Instead of synchronized?
================================================
â• Advantages:

| Feature               | `synchronized` | `ReentrantLock`                       |
| --------------------- | -------------- | ------------------------------------- |
| Explicit lock/unlock  | âŒ              | âœ…  lock()/unlock()                                |
| Try without waiting   | âŒ              | âœ… `tryLock()`                         |
| Timeout               | âŒ              | âœ… `tryLock(timeout)`                  |
| Interruptible waiting | âŒ              | âœ… `lockInterruptibly()`               |
| Fairness control      | âŒ              | âœ… FIFO with `new ReentrantLock(true)` |


ğŸš¨ Important: Always Unlock!
Because you manually lock and unlock, forgetting to call unlock() can cause deadlocks.
 Always use try-finally as shown.
 
 
 âœ… General Guideline: Base Lock Choice on Task Characteristics
 ==============================================================
 Letâ€™s go through it logically â€” task by task.
 
 | Task Type                 | Lock Type                                                     | Why?                                                                                                  |
| ------------------------- | ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| ğŸ” **lock()**             | For **critical, must-complete operations** (e.g., withdraw)   | We **must not skip** this operation. If the lock is held, the thread waits patiently.                 |
| ğŸŸ¡ **tryLock()**          | For **optional, non-urgent operations** (e.g., deposit UI)    | If lock is busy, skip or defer. Useful in **non-blocking UI or retries**.                             |
| â±ï¸ **tryLock(timeout)**   | For **time-sensitive reads or actions** (e.g., balance check) | Youâ€™re willing to wait a little, but **not forever**. Fails gracefully.                               |
| â— **lockInterruptibly()** | For **cancelable or stoppable tasks** (e.g., transfer)        | Long-running or blocking ops that **should stop if requested**, like canceled transfers, user aborts. |
 
 
